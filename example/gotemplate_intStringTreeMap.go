// Code generated by gotemplate. DO NOT EDIT.

// Copyright (c) 2018 Igor Mikushkin <igor.mikushkin@gmail.com>.
// All rights reserved. This program is free software. It comes without
// any warranty, to the extent permitted by applicable law. You can
// redistribute it and/or modify it under the terms of the Do What
// The Fuck You Want To Public License, Version 2, as published by
// Sam Hocevar. See LICENSE file for more details or see below.
//

//
//        DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
//                    Version 2, December 2004
//
// Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>
//
// Everyone is permitted to copy and distribute verbatim or modified
// copies of this license document, and changing it is allowed as long
// as the name is changed.
//
//            DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
//   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
//
//  0. You just DO WHAT THE FUCK YOU WANT TO.
//

/*
Package treemap uses red-black tree under the hood.
This is gotemplate ready package.
You can use it as a template to generate TreeMap with specific Key and Value types.

Generating TreeMap with int keys and string values
	package main

	import "fmt"

	//go:generate gotemplate "github.com/igrmk/treemap" "intStringTreeMap(int, string)"

	func less(x int, y int) bool { return x < y }

	func main() {
		tr := newIntStringTreeMap(less)
		tr.Set(0, "Hello")
		tr.Set(1, "World")

		for it := tr.Iterator(); it.HasNext(); {
			k, v := it.Next()
			fmt.Println(k, v)
		}
	}
It is not thread safe.
*/
package main

import (
	"runtime"
)

type colorIntStringTreeMap bool

const (
	redIntStringTreeMap   colorIntStringTreeMap = true
	blackIntStringTreeMap colorIntStringTreeMap = false
)

// template type TreeMap(Key, Value)

// Key is a generic key type of the map

// Value is a generic value type of the map

type nodeIntStringTreeMap struct {
	left   *nodeIntStringTreeMap
	right  *nodeIntStringTreeMap
	parent *nodeIntStringTreeMap
	color  colorIntStringTreeMap
	key    int
	value  string
}

var sentinelIntStringTreeMap = &nodeIntStringTreeMap{left: nil, right: nil, parent: nil, color: blackIntStringTreeMap}

func init() {
	sentinelIntStringTreeMap.left, sentinelIntStringTreeMap.right = sentinelIntStringTreeMap, sentinelIntStringTreeMap
}

// TreeMap is the red-black tree based map
type intStringTreeMap struct {
	root  *nodeIntStringTreeMap
	count int
	less  func(int, int) bool
}

// New creates the new red-black tree based TreeMap.
// Parameter less is a function returning a < b.
func newIntStringTreeMap(less func(a int, b int) bool) *intStringTreeMap {
	return &intStringTreeMap{
		root: sentinelIntStringTreeMap,
		less: less,
	}
}

// Set the value. Silently override previous value if exists. This will overwrite the existing value.
// Complexity: O(log N).
func (t *intStringTreeMap) Set(id int, value string) {
	t.insertNode(id, value)
}

// Del deletes the value.
// Complexity: O(log N).
func (t *intStringTreeMap) Del(id int) {
	t.deleteNode(t.findNode(id))
}

// Get retrieves a value from a map for specified key and reports if it exists.
// Complexity: O(log N).
func (t *intStringTreeMap) Get(id int) (string, bool) {
	nodeIntStringTreeMap := t.findNode(id)
	if nodeIntStringTreeMap == sentinelIntStringTreeMap {
		return nodeIntStringTreeMap.value, false
	}
	return nodeIntStringTreeMap.value, true
}

// Contains checks if key exists in a map.
// Complexity: O(log N)
func (t *intStringTreeMap) Contains(id int) bool {
	return t.findNode(id) != sentinelIntStringTreeMap
}

// Count returns total count of elements in a map.
// Complexity: O(1).
func (t *intStringTreeMap) Count() int {
	return t.count
}

// Clear clears the map.
// Complexity: O(1).
func (t *intStringTreeMap) Clear() *intStringTreeMap {
	t.root = sentinelIntStringTreeMap
	t.count = 0
	runtime.GC()
	return t
}

// Max returns maximum key and associated value.
// Complexity: O(log N).
func (t *intStringTreeMap) Max() (int, string) {
	current := t.root
	for current.right != sentinelIntStringTreeMap {
		current = current.right
	}
	return current.key, current.value
}

// Min returns minimum key and associated value.
// Complexity: O(log N).
func (t *intStringTreeMap) Min() (int, string) {
	current := t.root
	for current.left != sentinelIntStringTreeMap {
		current = current.left
	}
	return current.key, current.value
}

// Range returns an iterator such that it goes through all the keys in the range [from, to].
// Complexity: O(log N).
func (t *intStringTreeMap) Range(from, to int) forwardIteratorIntStringTreeMap {
	lower := t.LowerBound(from)
	upper := t.UpperBound(to)
	return forwardIteratorIntStringTreeMap{tree: t, node: lower.node, end: upper.node}
}

// LowerBound returns an iterator such that it goes through all the keys in the range [key, max(key)] by analogy with C++.
// Complexity: O(log N).
func (t *intStringTreeMap) LowerBound(key int) forwardIteratorIntStringTreeMap {
	nodeIntStringTreeMap := t.root
	result := sentinelIntStringTreeMap
	if nodeIntStringTreeMap == sentinelIntStringTreeMap {
		return forwardIteratorIntStringTreeMap{tree: t, node: sentinelIntStringTreeMap, end: sentinelIntStringTreeMap}
	}
	for {
		if t.less(nodeIntStringTreeMap.key, key) {
			if nodeIntStringTreeMap.right != sentinelIntStringTreeMap {
				nodeIntStringTreeMap = nodeIntStringTreeMap.right
			} else {
				return forwardIteratorIntStringTreeMap{tree: t, node: result, end: sentinelIntStringTreeMap}
			}
		} else {
			result = nodeIntStringTreeMap
			if nodeIntStringTreeMap.left != sentinelIntStringTreeMap {
				nodeIntStringTreeMap = nodeIntStringTreeMap.left
			} else {
				return forwardIteratorIntStringTreeMap{tree: t, node: result, end: sentinelIntStringTreeMap}
			}
		}
	}
}

// UpperBound returns an iterator such that it goes through all the keys in the range (key, max(key)] by analogy with C++.
// Complexity: O(log N).
func (t *intStringTreeMap) UpperBound(key int) forwardIteratorIntStringTreeMap {
	nodeIntStringTreeMap := t.root
	result := sentinelIntStringTreeMap
	if nodeIntStringTreeMap == sentinelIntStringTreeMap {
		return forwardIteratorIntStringTreeMap{tree: t, node: sentinelIntStringTreeMap, end: sentinelIntStringTreeMap}
	}
	for {
		if !t.less(key, nodeIntStringTreeMap.key) {
			if nodeIntStringTreeMap.right != sentinelIntStringTreeMap {
				nodeIntStringTreeMap = nodeIntStringTreeMap.right
			} else {
				return forwardIteratorIntStringTreeMap{tree: t, node: result, end: sentinelIntStringTreeMap}
			}
		} else {
			result = nodeIntStringTreeMap
			if nodeIntStringTreeMap.left != sentinelIntStringTreeMap {
				nodeIntStringTreeMap = nodeIntStringTreeMap.left
			} else {
				return forwardIteratorIntStringTreeMap{tree: t, node: result, end: sentinelIntStringTreeMap}
			}
		}
	}
}

// Iterator returns an iterator for tree map.
// It starts at the one-before-the-start position and goes to the end.
// You can iterate a map at O(N) complexity.
func (t *intStringTreeMap) Iterator() forwardIteratorIntStringTreeMap {
	nodeIntStringTreeMap := t.root
	for nodeIntStringTreeMap.left != sentinelIntStringTreeMap {
		nodeIntStringTreeMap = nodeIntStringTreeMap.left
	}
	return forwardIteratorIntStringTreeMap{tree: t, node: nodeIntStringTreeMap, end: sentinelIntStringTreeMap}
}

// Reverse returns a reverse iterator for tree map.
// It starts at the one-past-the-end position and goes to the beginning.
// You can iterate a map at O(N) complexity.
func (t *intStringTreeMap) Reverse() reverseIteratorIntStringTreeMap {
	nodeIntStringTreeMap := t.root
	for nodeIntStringTreeMap.right != sentinelIntStringTreeMap {
		nodeIntStringTreeMap = nodeIntStringTreeMap.right
	}
	return reverseIteratorIntStringTreeMap{tree: t, node: nodeIntStringTreeMap, end: sentinelIntStringTreeMap}
}

func (t *intStringTreeMap) rotateLeft(x *nodeIntStringTreeMap) {
	y := x.right
	x.right = y.left
	if y.left != sentinelIntStringTreeMap {
		y.left.parent = x
	}
	if y != sentinelIntStringTreeMap {
		y.parent = x.parent
	}
	if x.parent != nil {
		if x == x.parent.left {
			x.parent.left = y
		} else {
			x.parent.right = y
		}
	} else {
		t.root = y
	}
	y.left = x
	if x != sentinelIntStringTreeMap {
		x.parent = y
	}
}

func (t *intStringTreeMap) rotateRight(x *nodeIntStringTreeMap) {
	y := x.left
	x.left = y.right
	if y.right != sentinelIntStringTreeMap {
		y.right.parent = x
	}
	if y != sentinelIntStringTreeMap {
		y.parent = x.parent
	}
	if x.parent != nil {
		if x == x.parent.right {
			x.parent.right = y
		} else {
			x.parent.left = y
		}
	} else {
		t.root = y
	}
	y.right = x
	if x != sentinelIntStringTreeMap {
		x.parent = y
	}
}

func (t *intStringTreeMap) insertFixup(x *nodeIntStringTreeMap) {
	for x != t.root && x.parent.color == redIntStringTreeMap {
		if x.parent == x.parent.parent.left {
			y := x.parent.parent.right
			if y.color == redIntStringTreeMap {
				x.parent.color = blackIntStringTreeMap
				y.color = blackIntStringTreeMap
				x.parent.parent.color = redIntStringTreeMap
				x = x.parent.parent
			} else {
				if x == x.parent.right {
					x = x.parent
					t.rotateLeft(x)
				}
				x.parent.color = blackIntStringTreeMap
				x.parent.parent.color = redIntStringTreeMap
				t.rotateRight(x.parent.parent)
			}
		} else {
			y := x.parent.parent.left
			if y.color == redIntStringTreeMap {
				x.parent.color = blackIntStringTreeMap
				y.color = blackIntStringTreeMap
				x.parent.parent.color = redIntStringTreeMap
				x = x.parent.parent
			} else {
				if x == x.parent.left {
					x = x.parent
					t.rotateRight(x)
				}
				x.parent.color = blackIntStringTreeMap
				x.parent.parent.color = redIntStringTreeMap
				t.rotateLeft(x.parent.parent)
			}
		}
	}
	t.root.color = blackIntStringTreeMap
}

func (t *intStringTreeMap) insertNode(id int, value string) {
	current := t.root
	var parent *nodeIntStringTreeMap
	for current != sentinelIntStringTreeMap {
		if id == current.key {
			current.value = value
			return
		}
		parent = current
		if t.less(id, current.key) {
			current = current.left
		} else {
			current = current.right
		}
	}
	x := &nodeIntStringTreeMap{
		value:  value,
		parent: parent,
		left:   sentinelIntStringTreeMap,
		right:  sentinelIntStringTreeMap,
		color:  redIntStringTreeMap,
		key:    id,
	}
	if parent != nil {
		if t.less(id, parent.key) {
			parent.left = x
		} else {
			parent.right = x
		}
	} else {
		t.root = x
	}
	t.insertFixup(x)
	t.count++
}

// nolint: gocyclo
func (t *intStringTreeMap) deleteFixup(x *nodeIntStringTreeMap) {
	for x != t.root && x.color == blackIntStringTreeMap {
		if x == x.parent.left {
			w := x.parent.right
			if w.color == redIntStringTreeMap {
				w.color = blackIntStringTreeMap
				x.parent.color = redIntStringTreeMap
				t.rotateLeft(x.parent)
				w = x.parent.right
			}
			if w.left.color == blackIntStringTreeMap && w.right.color == blackIntStringTreeMap {
				w.color = redIntStringTreeMap
				x = x.parent
			} else {
				if w.right.color == blackIntStringTreeMap {
					w.left.color = blackIntStringTreeMap
					w.color = redIntStringTreeMap
					t.rotateRight(w)
					w = x.parent.right
				}
				w.color = x.parent.color
				x.parent.color = blackIntStringTreeMap
				w.right.color = blackIntStringTreeMap
				t.rotateLeft(x.parent)
				x = t.root
			}
		} else {
			w := x.parent.left
			if w.color == redIntStringTreeMap {
				w.color = blackIntStringTreeMap
				x.parent.color = redIntStringTreeMap
				t.rotateRight(x.parent)
				w = x.parent.left
			}
			if w.right.color == blackIntStringTreeMap && w.left.color == blackIntStringTreeMap {
				w.color = redIntStringTreeMap
				x = x.parent
			} else {
				if w.left.color == blackIntStringTreeMap {
					w.right.color = blackIntStringTreeMap
					w.color = redIntStringTreeMap
					t.rotateLeft(w)
					w = x.parent.left
				}
				w.color = x.parent.color
				x.parent.color = blackIntStringTreeMap
				w.left.color = blackIntStringTreeMap
				t.rotateRight(x.parent)
				x = t.root
			}
		}
	}
	x.color = blackIntStringTreeMap
}

// nolint: gocyclo
func (t *intStringTreeMap) deleteNode(z *nodeIntStringTreeMap) {
	var x, y *nodeIntStringTreeMap
	if z == nil || z == sentinelIntStringTreeMap {
		return
	}
	if z.left == sentinelIntStringTreeMap || z.right == sentinelIntStringTreeMap {
		y = z
	} else {
		y = z.right
		for y.left != sentinelIntStringTreeMap {
			y = y.left
		}
	}
	if y.left != sentinelIntStringTreeMap {
		x = y.left
	} else {
		x = y.right
	}
	x.parent = y.parent
	if y.parent != nil {
		if y == y.parent.left {
			y.parent.left = x
		} else {
			y.parent.right = x
		}
	} else {
		t.root = x
	}
	if y != z {
		z.key = y.key
		z.value = y.value
	}
	if y.color == blackIntStringTreeMap {
		t.deleteFixup(x)
	}
	t.count--
}

func (t *intStringTreeMap) findNode(id int) *nodeIntStringTreeMap {
	current := t.root
	for current != sentinelIntStringTreeMap {
		if id == current.key {
			return current
		}
		if t.less(id, current.key) {
			current = current.left
		} else {
			current = current.right
		}
	}
	return sentinelIntStringTreeMap
}

// ForwardIterator represents a position in a tree map.
// It starts at the one-before-the start position and goes to the end.
type forwardIteratorIntStringTreeMap struct {
	tree *intStringTreeMap
	node *nodeIntStringTreeMap
	end  *nodeIntStringTreeMap
}

// HasNext reports if we have elements after current position
func (i forwardIteratorIntStringTreeMap) HasNext() bool { return i.node != i.end }

// Next returns next element from a tree map.
// It panics if goes out of bounds.
func (i *forwardIteratorIntStringTreeMap) Next() (key int, value string) {
	if i.node == i.end {
		panic("out of bound iteration")
	}
	key, value = i.node.key, i.node.value
	if i.node.right != sentinelIntStringTreeMap {
		i.node = i.node.right
		for i.node.left != sentinelIntStringTreeMap {
			i.node = i.node.left
		}
		return
	}
	for i.node.parent != nil {
		i.node = i.node.parent
		if !i.tree.less(i.node.key, key) {
			return
		}
	}
	i.node = i.end
	return
}

// ReverseIterator represents a position in a tree map.
// It starts at the one-past-the-end position and goes to the beginning.
type reverseIteratorIntStringTreeMap struct {
	tree *intStringTreeMap
	node *nodeIntStringTreeMap
	end  *nodeIntStringTreeMap
}

// HasNext reports if we have elements after current position
func (i reverseIteratorIntStringTreeMap) HasNext() bool { return i.node != i.end }

// Next returns next element from a tree map
func (i *reverseIteratorIntStringTreeMap) Next() (key int, value string) {
	if i.node == i.end {
		panic("out of bound iteration")
	}
	key, value = i.node.key, i.node.value
	if i.node.left != i.end {
		i.node = i.node.left
		for i.node.right != i.end {
			i.node = i.node.right
		}
		return
	}
	for i.node.parent != nil {
		i.node = i.node.parent
		if !i.tree.less(key, i.node.key) {
			return
		}
	}
	i.node = i.end
	return
}
